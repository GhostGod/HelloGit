美团

一面

自我介绍

答：自我介绍是面试中唯一的自己主动介绍自己的环节，一定要好好把握好，你数据结构学的号可以手撕一个红黑树你就说我数据结构掌握地很好，反正就是要把自己的优势凸显出来，比如我是保研的以及对于java的知识较熟悉，我介绍完自己的本科经历以后，我就说我是保送到本校继续读研究生，然后最末尾会加上自己熟悉java，然后面试官就会问java的一些东西；

项目介绍及其亮点

答：这篇文章可以作为你面试的项目亮点的文章，不来看看吗？

java的8种数据类型有哪些？

答：感觉这个问题被问烂了，int,short,long,float,double,byte,boolean,char;

问了Integer缓存数据的范围？

答：-128-127

紧接着问了Object类有哪些方法？

答：这个我有背过，clone,getClass,toString,finalize,equals,hashCode,wait,notify,notifyALL。

问到这里然后拿出了一个题，面试官有小纸条，题目在上面，String A = "123"; String B = new String("123");，问我生成了几个String对象？

答：我说如果常量池中，原来没有“123”那么就是生成了2个对象，如果常量池中有“123”那么只要1个对象生成

由于提到了wait,顺带问了wait和sleep有什么区别？

答：wait的话会释放对象锁，sleep的话不会释放的对象锁

由于还提及了hashcode，面试官接着问我，hashcode用在哪里？

答：这个我不假思索地说，hashmap和ConcurrentMap，这里我猜面试官肯定要继续问我这两个东西了。

果不其然，面试官说，讲一讲hashmap?

答：hashmap我讲了hashmap的数据结构数组链表结构，讲了hashmap的put,get,扩容的底层原理，同时讲了hashmap在1.7与1.8中的区别，put中引入了红黑树，以及扩容的时候不同，这些就讲了挺长时间，最后我说了一句hashmap不是线程安全的。

这里提及了hashMap是非线程安全的，面试问我为啥不是线程安全的，举几个例子？

答：我说了，在扩容的时候hashmap会可能产生环，造成死循环；hashmap在插入新的阶段的时候，多个线程同时插入，会把除了最后的那个线程的其它线程插入的结点丢失；对于修改的时候，多个线程修改，对只保留最后的一个线程的修改结果；扩容的时候，会只保留最后一个线程的扩容后的那个数组；从扩容修改增加说了一遍；

我本以为要接着问ConCurrentMap，额，出乎我的意料，并没有问，可能觉得我hashmap准备的很充分，然后接着问了我JVM了解吗？

答：我说了解；

让我说意思JVM的分为哪几块？

答：方法区，虚拟机栈，本地方法栈，堆，程序计数器，然后我就自己没等面试官问新的问题，继续接着说，方法区和堆是线程共享的，虚拟机栈本地方法栈和程序计数器是线程私有的，除了程序技术器不会发生内存溢出，其它都会发生内存溢出，并说了哪些会发生堆溢出哪些会发生栈溢出；这里就是大家要学会自己吧啦吧啦地说一堆，因为据我观察每个面试官面试每个是有一个固定时间的，超过这个时间段就结束了，所以只要面试官不打断你，你就一顿说；

由于提及到了内存溢出，面试官问我内存溢出和内存泄漏的区别？

答：内存泄露我说就是一块申请了一块内存以后，无法去释放掉这块内存，丢失了这段内存的引用；内存溢出就是申请的内存不够，撑不起我们需要的内存；

这里问完我就去问了数据库，4大特性是啥，举个例子？

答：原子性，我说就是一个事务要么全部完成，要么全部失败，要么做要么不做；一致性，比如a+b=100,一个事务改变了a比如增加了a的值，那么必须同时改变b，保证在事务结束以后a+b=100依然成立，这就是一致性；持久性，额就是修改完以后，在数据库中生效是永久的；隔离性，我就是说对于A对B进行转账，A没把这个交易完成的时候，B是不知道A要给他转钱。

数据的隔离级别有啥，每个隔离级别举个例子？

答：额，（怎么都要举例子啊，啊啊啊啊~），内心波澜，脸上面无表情地说：1.未提交读，事务中发生了修改，即使没有提交，其它事务也是可见的，举例子我就说对于一个数A原来50修改为100，但是我还没有提交修改，另一个事务看到这个修改，而这个时候原事务发生了回滚，这时候A还是50，但是另一个事务看到的A是100，这就是未提交读；2.提交读，就是说，对于一个事务从开始直到提交之前，所做的任何修改是其它事务不可见的，举例就是对于一个数A原来是50，然后提交修改成100，这个时候另一个事务在A提交修改之前，读取到了A是50，刚读取完，A就被修改成100了，这个时候另一个事务再进行读取发现A就突然变成100了；3.可重复读；可重复读，就是对于一个记录读取多次的记录是相同的，举例就是对于一个数A读取的话一直是A，前后两次读取到的A是一致的；可串行化读，就是说在并发情况下，和串行化的读取的结果是一致的，没有什么不同，这个举例我就说，不会发生脏读和幻读；然后数据库这一块就过去了。

接着问我计算机网络，问了我7层有哪7层？

答：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层；

接着问了我TCP在哪层，UDP在哪层，HTTP在哪层？

答：TPC和UDP在传输层，然后HTTP问我在哪个层，我一下有点忘了，这个没答上来，会去看了是在应用层。

问到这里就结束了，然后面试官问我有啥想问的，我就问如何评价我的面试表现？

答：因为一面都是问基础的知识，面试官和我说，我感觉你基础很扎实，他直接和我说我这里的话是通过的，不知道后面的面试官怎么问你，然后我说了声谢谢，就去酒店的一个会议厅等待二面；

二面

一面过了没多久，就立马通知二面了，中途感觉有点饿了，美团还挺人性话的，在后面的桌子上放了一堆饼干，忘了饼干的名字了，总之特别好吃，我吃了好几块。

自我介绍

项目介绍，及其亮点介绍。

答：这个继续这篇文章就是背；可以作为你面试的项目亮点的文章，不来看看吗？

然后问了我集合了解吗，让我说话ArrayList和LinkedList的区别？

答：ArrayList底层是数组，LinkedList底层是链表，ArrayLIst查找数据快，LinkedList插入删除快；

继续问我linkedList可以用for循环遍历吗？

答;能不用尽量不要用，linkedList底层是链表，它使用for进行遍历，访问每一个元素都是从头开始访问然后直到找到这个元素，比如说找第三个节点，需要先找到第一个节点然后找到第二个节点；继续找第4个节点，不是从第三个节点开始找的，还是从第一个节点开始，所以非常的慢，不推荐，可以用迭代器进行遍历。

介绍一下ConCurrenthashmap

答：我感觉是因为一面问了hashmap，所以二面面试官可能是看见了面试记录，额，这块我非常熟，这个我又讲了很长时间，讲了ConCurrentHashMap的底层的分段锁的结构，讲了ConCurrentHashmap的get源码，get源码是没有使用锁的，这里我把get源码背写了下来，并给面试官讲了get源码在插入修改删除的多线程下是安全的；然后讲了put操作，remove,扩容操作，然后讲了在1.7和1.8的区别，引入了红黑树，链表长度大于8转换成红黑树，采用了CAS+synchronized来保证并发安全，吧啦吧啦又讲了挺长时间；

来看看这道题，说着拿出来一个小纸条

答：这个纸条感觉每个面试官都是只有纸条，所以尽可能地和周围的同学多交流，有一定的肯可能他的面试官就你的面试官。题目：让我自己手算a,b,c,d的值，

 1public class Main {
 2    public static void main(String [] args)
 3    {
 4        int a = 10 &gt;&gt; 1;
 5        int b  = a++;
 6        int c = ++a;
 7        int d = b * a++;
 8        System.out.println(a);
 9        System.out.println(b);
10        System.out.println(c);
11        System.out.println(d);
12    }
13}
结果是a = 8b=5,c=7,d=35.计算完我问他对不对，他没勒我。。。

然后问我单利模式了解不，写一个单例模式？

答：这个之前准备过，我写了一个双重锁的单例模式。

 1public class SingletonDemo {
 2    private volatile static SingletonDemo instance;
 3    private SingletonDemo(){
 4        System.out.println("Singleton has loaded");
 5    }
 6    public static SingletonDemo getInstance(){
 7        if(instance==null){
 8            synchronized (SingletonDemo.class){
 9                if(instance==null){
10                    instance=new SingletonDemo();
11                }
12            }
13        }
14        return instance;
15    }
16}
接着问了我虚拟机了解吗，介绍一些虚拟机的内存模型？

答：这个之前也准备过，这里要注意了，虚拟机的内存模型和运行时的数据区域不是一回事；虚拟机内存模型又叫JMM，就是每个线程有自己的工作内存，然后又一个主内存，线程工作的时候都是在自己的工作内存中拷贝一个主内存的副本；还说了JMM的happens before原则，程序顺序原则，锁原则，线程中断原则，传递性原则，还有其他的没想起来就没说了。

介绍一些你了解的垃圾回收算法？

答：标记清除，标记整理，复制算法，把每个算法是啥说了一遍；

问到这里，问了我你知道SurvivorRatio这个参数为啥初始是默认的8:1:1吗？

答：这个由于刚才刚问了垃圾回收算法，我觉得可能有关联，于是我说，方便复制算法操作，Eden区域大多数都是朝生夕死的，这个比例，可以方便复制算法的中from和to来回进行复制存活的对象，额，说完，他没有说啥，感觉是默许了吧；

突然又问，二叉树了解吗，写一个二叉树的深度搜索遍历？

答：当时我听到中道题，有点懵，什么是二叉树的深度搜索遍历，我只知道层次遍历，前序后序中序遍历啊，我想了想，感觉和后序遍历挺像的，我觉得应该就是后序遍历吧，我就先写了个后序遍历的递归写法

 1void DFS(TreeNode root)
 2{
 3    if(root == null)
 4        return;
 5    if(root.left != null)
 6        DFS(root.left);
 7    if(root.right != null)
 8        DFS(root.right);
 9    System.out.println(root.val);
10}
，然后他看了一眼，没说啥，感觉这个面试官有点话少冷淡，全程不和我互动，emmmm....下来自己百度了下，对的。。。

这个代码问完我，让后让我去等通知，我感觉回答的还行，果然没过几分钟，通知我去三面；

三面

照例自我介绍和项目介绍；

上来就让我手撕一个单例模式。。。

答：继续写我的双重锁模式

 1public class SingletonDemo {
 2    private volatile static SingletonDemo instance;
 3    private SingletonDemo(){
 4        System.out.println("Singleton has loaded");
 5    }
 6    public static SingletonDemo getInstance(){
 7        if(instance==null){
 8            synchronized (SingletonDemo.class){
 9                if(instance==null){
10                    instance=new SingletonDemo();
11                }
12            }
13        }
14        return instance;
15    }
16}
，

让我讲了讲代码是啥啥意思？

答：STEP 1. 线程A访问getInstance()方法，因为单例还没有实例化，所以进入了锁定块。STEP 2. 线程B访问getInstance()方法，因为单例还没有实例化，得以访问接下来代码块，而接下来代码块已经被线程1锁定。STEP 3. 线程A进入下一判断，因为单例还没有实例化，所以进行单例实例化，成功实例化后退出代码块，解除锁定。STEP 4. 线程B进入接下来代码块，锁定线程，进入下一判断，因为已经实例化，退出代码块，解除锁定。STEP 5. 线程A初始化并获取到了单例实例并返回，线程B获取了在线程A中初始化的单例。大体是这么回事。

由于我的项目中提及到JVM，所以给我出了一个场景题，垃圾会收器中，标记清除多次后，由于采用的是标记清除算法，那么你觉得可能会出现什么问题？

答：然后我说由于产生了内存碎片，所以当分配一个大对象的时候，由于内存不连续，那么会产生full GC;

这里提及到了full gc,问我，哪些情况会产生full GC,哪些情况产生minor GC?

答：minor会产生在eden区满了，fullGC产生在老年代的剩余空间不足，以及永久代内存不足也会发生fullGC。

除了你项目中的内存溢出问题，你还知道哪些关于内存溢出内存泄漏的？

答：这里之前了解过ThreadLocal,我说，ThreadLocal中的键值对中的键是一个弱引用，那么在内存回收的时候，这个键很可能会被回收掉，然后键没了，就无法找到value的值，造成了内存泄漏；

然后给我出了一个动态规划的手写代码题，说来写个代码吧，大体是在n*m的矩阵方格中，找一个最大的正方形是几乘几的，有点忘了，

答：由于没有准备过动态规划的题目，这个题目看到我只说了暴力解决的方法，然后面试官提示让我用动态规划做，我想了半天没想出来。。。。当时感觉应该是凉了。。。

时间差不多的时候，面试官说，就到这里吧，然后让我出去等通知，果然通知我今天面试结束了，整整一个下午，特别特别累，前两面结束的时候感觉特别稳，没想到最后还是因为手写代码这一块不会动态规划挂掉了，当时感觉心态有点崩。。。
